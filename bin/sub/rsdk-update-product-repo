#!/usr/bin/env bash

update_repo() {
	local PRODUCT="${1}"
	local RSDK_BUILD_ORG="radxa-build"
	local OUTPUT_ROOT="$PWD/out"
	local OUTPUT="$OUTPUT_ROOT/$RSDK_BUILD_ORG/${PRODUCT}"
	local TEMPLATE_DIR="$SCRIPT_DIR/../../templates"
	local TEMPLATE="$TEMPLATE_DIR/build-image"

	if [[ $RSDK_OPTION_DRY_RUN == "false" ]] && ! gh auth status &>/dev/null; then
		echo "This operation requires GitHub authentication:"
		if ! gh auth login; then
			error "$EXIT_AUTHENTICATION_FAILED" "github"
		fi
	fi

	if [[ $RSDK_OPTION_DRY_RUN == "true" ]]; then
		echo "Dry run. Will only update local repo."
		mkdir -p "$OUTPUT"
		pushd "$OUTPUT"
		git init
		popd
	elif [[ -e "$OUTPUT/.git" ]] && (cd "$OUTPUT" && [[ -n $(git remote) ]]); then
		echo "Found existing repository. Updating..."
		pushd "$OUTPUT"
		git fetch --all
		git pull
		popd
	else
		rm -rf "$OUTPUT"
		mkdir -p "$OUTPUT_ROOT/$RSDK_BUILD_ORG"
		echo "Trying to clone existing repository first..."
		if ! gh repo clone "$RSDK_BUILD_ORG/$PRODUCT" "$OUTPUT"; then
			echo "Target repository does not exist. New repository will be created."
			pushd "$OUTPUT_ROOT/$RSDK_BUILD_ORG"
			gh repo create "$RSDK_BUILD_ORG/$PRODUCT" --clone --public
			popd
		fi
	fi

	echo "Remove existing content..."
	find "$OUTPUT" -mindepth 1 -maxdepth 1 ! -name .git -exec rm -rf {} +

	echo "Prepare folder structure..."
	pushd "$TEMPLATE"
	find . -mindepth 1 -type d -exec mkdir -p "$OUTPUT/{}" \;
	popd

	echo "Populate content..."
	JSONNET_ARGS=(
		"-S"
		"--tla-str" "product=$PRODUCT"
		"--tla-str" "build_org=$RSDK_BUILD_ORG"
		"--multi" "$OUTPUT"
	)

	jsonnet "${JSONNET_ARGS[@]}" "$TEMPLATE/template.jsonnet"

	pushd "$OUTPUT"
	if [[ -n "$(git status --porcelain)" ]]; then
		git config --local user.name "github-actions[bot]"
		git config --local user.email "41898282+github-actions[bot]@users.noreply.github.com"
		git add .
		git commit -m "chore: templates updated by rsdk $(git rev-parse --short "HEAD^{commit}")$(! git diff --quiet && echo .dirty)"
	fi

	if [[ $RSDK_OPTION_DRY_RUN == "false" ]]; then
		git push --set-upstream origin main
		gh repo edit --description "$(jq -r --arg product "$PRODUCT" '.[] | select(.product == $product).product_full_name' "$SCRIPT_DIR/../../configs/products.json")"
	fi
	popd
}

main() {
	local SCRIPT_DIR
	SCRIPT_DIR="$(dirname "$(realpath "$0")")"
	# shellcheck source=bin/lib/utils.sh
	source "$SCRIPT_DIR/../lib/utils.sh"

	local TEMP
	if ! TEMP="$(getopt -o "hd" -l "help,dry-run" -n "$0" -- "$@")"; then
		return
	fi
	eval set -- "$TEMP"

	export RSDK_OPTION_DRY_RUN="${RSDK_OPTION_DRY_RUN:-false}"

	while true; do
		TEMP="$1"
		shift
		case "$TEMP" in
		-d | --dry-run)
			RSDK_OPTION_DRY_RUN="true"
			;;
		-h | --help)
			TEMP="$(basename "$0")"
			rsdk help "${TEMP#rsdk-}"
			return
			;;
		--)
			break
			;;
		*)
			error $EXIT_UNKNOWN_OPTION "$TEMP"
			;;
		esac
	done

	if (($# == 0)); then
		read -rp "No product supplied. Do you want to update ALL supported products? [y/N] "
		if [[ ${REPLY/Y/y} == "y" ]]; then
			local products
			mapfile -t products < <(jq -r '.[].product' "$SCRIPT_DIR/../../configs/products.json")
			set -- "${products[@]}"
		else
			echo "Operation cancelled."
			return
		fi
	fi

	while (($# != 0)); do
		update_repo "$1"
		shift
	done
}

main "$@"
